{
  "id": "blog-8",
  "title": "大匠运斤 - 一致性哈希算法",
  "digest": {
    "articleUrl": "/page/tech/blog/blog-8/blog-8.html",
    "content": "一致性哈希算法是分布式系统中常用的算法。一致性哈希算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。",
    "picUrl": "/page/tech/pic/cache.jpeg",
    "tag": "架构",
    "title": "大匠运斤 - 一致性哈希算法"
  },
  "navType": "BLOG",
  "phases": [
    {
      "title": "背景",
      "segment": [
        "缓存集群设计经常会用到一致性哈希算法，在介绍一致性哈希算法时，得先搞清楚现实场景是什么样的，要解决什么样的架构问题。",
        "假设有十万条数据，要缓存到五台机器的缓存集群，为保持分布均匀，需在每台机器存放两万条数据。",
        "每台机器分布的数据量，取决于集群的负载均衡算法。假设我们使用轮询进行负载均衡，是能保证数据的均匀分布。但轮询会带来一个问题：在进行缓存查询时，只能遍历所有机器才能找到数据，很明显，分布式遍历机器是不现实的；",
        "另一种策略是对缓存键进行哈希来分配到具体的某台机器。举个栗子，假设有三条数据需缓存到规模为3台机器的集群里（机器编号为0、1、2），数据分别为：<a , 2><b , 8><c , 9>，我们取a、b、c三个缓存键进行哈希计算，得到哈希码1，2，3，再用哈希码对机器数进行取模运算：",
        "1 % 3 = 1（存储到1号机器）2 % 3 = 2（存储到2号机器）3 % 3 = 0（存储到0号机器）",
        "然后就能计算出数据的存储位置。数据存储后，若用户用数据键进行缓存查询，只需再做一次上述操作，就能迅速定位到缓存所在机器的位置了。哈希这种算法也能保证较为均匀的数据分布，数据查询高效且简单。",
        "不过，普通的哈希算法在分布式系统中仍有不足，因为算法的确定性依赖于机器的数量。而在分布式系统中，机器数量的变动是个时常发生的事情。当机器数量变动时，上述哈希取模计算的结果都会发生变化，从而导致大规模的缓存查询失效，导致缓存雪崩。",
        "为了防止机器数量变化导致的缓存雪崩，我们需要一种更为复杂的算法来减少它对缓存的影响，而解决之道就是：一致性哈希。"
      ]
    },
    {
      "title": "原理",
      "segment": [
        "理解一致性哈希的原理需要一定的想象力。",
        "首先，我们想象一个均匀分布着2^32（4294967296）个节点的环，称它为哈希环。",
        "然后，沿用上文介绍的哈希取模算法，对3台机器进行哈希取模（模数为2^32），得到三个小于2^32的数p1、p2、p3，并将他们对应到哈希环上去。",
        "接下来，我们对需要存储的数据也采取上述算法，也能得到几个小于2^32的数d1、d2、d3，对应到哈希环上。",
        "沿着哈希环顺时针的方向，我们必定能为d1、d2、d3分别找到距离它最近的一个机器，这个最近的机器，就是数据存储到的位置。",
        "由于数据的哈希取模结果是永远不变的，寻找数据所在的机器需要通过哈希环来完成，因此无论是加入一台机器还是减少一台机器，都只会影响一部分的数据而不是所有的数据，这就避免了上文提到的大规模缓存雪崩问题。"
      ]
    },
    {
      "title": "改善",
      "segment": [
        "哈希取模算法在样本较少时可能无法分布均匀。运气不好的情况下，散列机器IP时可能产生下图这种情况，导致大量数据缓存在一台机器上。如果数据都集中某台机器，当这台机器下线时，依然会出现缓存雪崩。",
        "改进方法，就是引入虚拟节点概念。",
        "什么叫虚拟节点？​散列机器IP时本来应该散列真实存在的机器，但是我们真实的机器肯定远少于2^32的台，因此我们可以虚拟出很多“不存在的机器”，关联某台真实物理机后，再散列到哈希环里去。当缓存请求落到这些虚拟节点时，由它们关联的真实物理机去处理，这样就能避免机器节点过少导致散列可能不均的问题了。"
      ]
    }
  ]
}
